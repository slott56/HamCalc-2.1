// Radio Design Calculator// Author:  Steven F. Lott (http://people.delphi.com/slott)// Reverse Engineered from George Murphy (VE3ERP) HamCalc v9.4// Some algorithmic improvements based on Numerical Recipes in C.// (c) 1997 Steven F. Lott// All rights reserved.  This software is provided as-is with no warranties of any kind.// You are free to reuse elements of this java package for non-commercial purposes// only if you include this comment.// You may not use this java package for any commercial (for-profit) purpose// of any kind without permission from the author.import java.awt.*;import java.applet.Applet;import java.util.Observable;import java.util.Observer;import java.lang.Math;import java.lang.Integer;import java.util.Vector;// A common requirement is for GUI components which are numeric.// These first classes establish some basic numeric component capabilities.// This interface specifies minimal behavior for a numerical component.// While typically text fields, they may also be choice components.interface NumComponent {	// accessors	public int getIntValue();	public double getDoubleValue();	// manipulators	public void setValue( int v );	public void setValue( double v );}// This subclass of TextField provides the needed functionality to make// a standard AWT text field into a component which satisfies the interface for// a NumComponentclass NumTextField extends java.awt.TextField implements NumComponent {	// accesssors	public int getIntValue() {		int v;		v= Integer.valueOf( getText() ).intValue();		return v;	}	public double getDoubleValue() {		double d;		d= Double.valueOf( getText() ).doubleValue();		return d;	}	// manipulators	public void setValue( int v ) {		setText( String.valueOf( v ) );	}	public void setValue( double v ) {		setText( String.valueOf( v ) );	}}// This subclass of Choice provides the needed functionality to make// a standard AWT choice into a component which satisfies the interface for// a NumComponent.class NumChoice extends Choice implements NumComponent {	// accessors	public int getIntValue() {		int v;		v= Integer.valueOf( getSelectedItem() ).intValue();		return v;	}	public double getDoubleValue() {		double d;		d= Double.valueOf( getSelectedItem() ).doubleValue();		return d;	}	// manipulators	public void setValue( int v ) {		//if it exists, select it		select( String.valueOf( v ) );	}	public void setValue( double v ) {		select( String.valueOf( v ) );	}}// The underlying engineering models require model components which have// some specific GUI behaviors.  Note that not all AWT components have// all of these behaviors.  This interface mandates stubs for the// missing functionality.// This is the list of GUI behaviors required by all model components.// Since the components must also be NumComponents, this extends the// basic NumComponent interface.interface ModelComponent extends NumComponent {	//accessors	public double getDoubleValue();	//manipulators	public boolean action(Event evt,Object what);	public boolean lostFocus(Event evt,Object what);	public void setOwnedBy( ModelField m );	public void setForeground( Color c );	public void requestFocus();	public void setEditable( boolean f );}// This extension to NumTextField passes GUI events to the underlying AWT TextField.class ModelNumTextField extends NumTextField implements ModelComponent {	ModelField theField;	//manipulators	public void setOwnedBy( ModelField m ) {  theField= m; }	public boolean action(Event evt,Object what) { return theField.action(evt,what); }	public boolean lostFocus(Event evt,Object what) { return theField.lostFocus(evt,what); }}// This extention to NumChoice stubs GUI events which the underlying AWT Choice// cannot do.class ModelNumChoice extends NumChoice implements ModelComponent {	ModelField theField;	//manipulators	public void setOwnedBy( ModelField m ) {  theField= m; }	public boolean action(Event evt,Object what) { return theField.action(evt,what); }	public boolean lostFocus(Event evt,Object what) { return theField.lostFocus(evt,what); }	public void requestFocus() { }	public void setEditable( boolean f ) { }}// This is the essential class for all fields of models.  It retains the current value// for the field, it maintains ModelComponent (text field or choice) to display the// get user input and display current values.// Since a model needs to determine what can be computed from what was input,// each field keeps the order in which the user entered data as well as static dependency// information.  Changes in the setOrder cause the model to compute fields from user// input fields.// It also keeps a label, which is static.class ModelField {	public ModelComponent theComponent;	// awt component for this field, usually											// a NumTextField, maybe a Choice	private double value;		// current value	private String theLabel;	// label for this variable	private int setOrder;		// order in which variables were set	public Model owner;		// owning model	private Vector dependsOn;	// fields on which this field depends	// CONSTRUCTORS	ModelField( Model o, String l, int[] d, ModelComponent c ) {		theLabel= l; owner= o;		if( d != null ) {			dependsOn= new Vector(d.length);			for( int i= 0; i != d.length; ++i ) {				dependsOn.addElement( new Integer( d[i] ) );			}		}		else {			dependsOn= new Vector(6);		}		theComponent= c;		c.setOwnedBy( this );		//if( ! enterable() ) { theComponent.setEditable(false); }	}	ModelField( Model o, String l, int[] d ) { this( o, l, d, new ModelNumTextField() ); }	ModelField( Model o, String l ) { this( o, l, null ); }	// MANIPULATORS	// change the current value, update the setOrder	public void set( double v ) {		setOrder= owner.updateSeq();		value= v;  setValue( v );		setForeground( Color.blue );	}	public void compute( double v ) {		value= v;  setValue( v );		setForeground( Color.magenta );	}	public void derive( double v ) {		value= v;  setValue( v );		setForeground( Color.red );	}	public ModelField addDependsOn( int d ) {		dependsOn.addElement( new Integer( d ) );		return this;	}	// delegations to ModelComponent, may be stubbed or handed off by the	// model component to an underlying AWT component	public void setEditable( boolean f ) { theComponent.setEditable(f); }	public void setValue( double v ) { theComponent.setValue(v); }	public void setForeground( Color c ) { theComponent.setForeground(c); }	public void requestFocus() { theComponent.requestFocus(); }	// respond to GUI event	// action is typically RETURN key, advance to next field	public boolean action(Event evt,Object what) {		//System.err.println(getClass().toString()+" action");		owner.fieldAfter(this);		return false;	}	// focus lost through mouse move, and RETURN key, compute and advance	public boolean lostFocus(Event evt,Object what) {		//System.err.println(getClass().toString()+" lostFocus");		owner.error("");		try {			set( getDoubleValue() );		}		catch( NumberFormatException e ) {			owner.error( "Invalid " + label() );		}		owner.fieldChange();		return false;	}	// mouse pass over could cause display of what might change if this were updated	//public boolean mouseEnter(Event evt,int x,int y) {		//System.err.println(getClass().toString()+" mouseEnter");		//owner.potential(this);		//return false;	//}	// entry could cause display of what will be computed if this is changed	//public boolean gotFocus(Event evt,Object what) {		//System.err.println(getClass().toString()+" gotFocus");		//return false;	//}	// ACCESSORS	public double getDoubleValue() { return theComponent.getDoubleValue(); }	public double get() { return value; }	public int seq() { return setOrder; }	// what I set after field f?	public boolean setAfter( ModelField f ) { return setOrder >= f.seq(); }	// what I ever set by the user?	public boolean wasSet() { return setOrder > 0; }	// what is my label?	public String label() { return theLabel; }	// am I computable based on the other fields of the model that owns me?	public boolean computable() {		// I am computable if everything I depend on was set after I last was set		boolean allAfterMe= true;		if( dependsOn == null || dependsOn.size() == 0 ) allAfterMe= false;		for( int i= 0; allAfterMe && i != dependsOn.size(); ++i ) {			int dep= ((Integer)dependsOn.elementAt(i)).intValue();			if( this.setAfter( owner.getField(dep) ) ) allAfterMe= false;		}		return allAfterMe;	}}// This is the superclass for all engineering models.  A model is essentially// a set of fields plus methods for computing a field based on user inputs// to other fields.// A specific model will override the constructor to assemble the fields// which comprise this model.  It will override title to display a title// for this model.  It will override the model function which is the central// update performed when user input changes a field.abstract class Model extends java.util.Observable implements java.util.Observer{	private Applet owner;				// the owning applet	public Panel thePanel;				// the immediate display panel	private int lastSet= 0;			// sequence of user inputs	private int numVariables;		// total number of variables	protected ModelField theFields[];	// set of variables	// CONSTRUCTORS	public Model( Applet o ) { owner= o; }	public Model( Applet o, int nv ) {		owner= o;		numVariables= nv;		theFields= new ModelField[numVariables];	}	// MANIPULATORS	// add a field to a model	public ModelField addField( int id, ModelField f ) { theFields[id]= f; return f; }	// interface required by ModelField objects	// provide this to a field when it changes	public int updateSeq() { ++lastSet; return lastSet; }	// provide this to a field when finishing "what-if" mode	public int sequence() { return lastSet+1; }	// display an error on behalf of a field	public void error(String s) { owner.showStatus(s); }	// sequence through text fields	public void fieldAfter(ModelField f) {		//thePanel.nextFocus();	// doesn't seem to work		//f.nextFocus();		// doesn't work either		int i= 0;		while( i != numVariables && ! f.equals(theFields[i]) ) { ++i; }		if( i != numVariables ) {			theFields[(i+1)%numVariables].requestFocus();		}	}	// determine what will be computed when field f changes	public void potential( ModelField f ) {		//find all fields which depend on this field		//ask them to change their color or something.	}	// update the models state when a field changes	public void set( int item, double value ) {		theFields[item].set( value );		fieldChange();	}	// Compute field f.  A prior call to computable determined that this field	// can be computed.  This function does the computation.	// Must be overridden by subclasses.	abstract protected double model( int f );	// announce a field change:  compute any fields computable and notify observers	public void fieldChange() {		boolean c= false;		for( int i= 0; i != numVariables; ++i ) {			if( computable(i) ) {				//System.err.println("Compute "+theFields[i].label());				c= true;				theFields[i].compute( model(i) );			}		}		if( c ) {			setChanged(); notifyObservers();		}	}	// Observables notify us via the update method.	// Grab any fields with names which match fields in this model.	// This is how data is passed from model to model.	public void update( Observable obj, Object what ) {		Model anotherModel= (Model)obj;		for( int i= 0; i != numVariables; ++i ) {			int otherModelField= anotherModel.ident( theFields[i].label() );			if( otherModelField != -1 ) {				//System.err.println("Field "+i+" matches "+otherModelField);				set( i, anotherModel.get( otherModelField ) );				//theFields[i].setValue( get(i) );			}		}	}	// Client interface ACCESSORS	abstract public String title();	public int numVariables() { return numVariables; }	public String getLabel( int item ) {		return theFields[item].label();	}	public ModelField getField( int item ) {		return theFields[item];	}	// Normally, we appeal to each field to have a specific list of	// dependencies.  Some models are more complex and may override this	// rule.	public boolean computable( int f ) {		return theFields[f].computable();	}	public double get( int item ) {		return theFields[item].get();	}	// when passing data from model to model, the field names must match	// this function determines the internal identification for a field,	// given the label.	public int ident( String name ) {		int ident= -1;		for( int i=0; ident == -1 && i != numVariables; ++i ) {			if( theFields[i].label().equals( name ) ) {				ident= i;			}		}		return ident;	}}class RTD_Statute extends Model {	public static final int RATE= 0;	public static final int TIME= 1;	public static final int DISTANCE= 2;	public String title() { return "Rate-Time-Distance"; }	public RTD_Statute( Applet o ) {		super(o,3);		addField( RATE, new ModelField( this, "Rate (mph)" ) );		theFields[RATE].addDependsOn( TIME );		theFields[RATE].addDependsOn( DISTANCE );		addField( TIME, new ModelField( this, "Time (hours)" ) );		theFields[TIME].addDependsOn( RATE );		theFields[TIME].addDependsOn( DISTANCE );		addField( DISTANCE, new ModelField( this, "Distance (miles)" ) );		theFields[DISTANCE].addDependsOn( RATE );		theFields[DISTANCE].addDependsOn( TIME );	}	protected double model( int item ) {		if( item == RATE ) {			double time= theFields[TIME].get();			double dist= theFields[DISTANCE].get();			return dist / time;		}		if( item == TIME ) {			double rate= theFields[RATE].get();			double dist= theFields[DISTANCE].get();			return dist / rate;		}		if( item == DISTANCE ) {			double time= theFields[TIME].get();			double rate= theFields[RATE].get();			return rate * time;		}		return 0.0;	}}class RTD_Nautical extends Model {	public static final int RATE= 0;	public static final int TIME= 1;	public static final int DISTANCE= 2;	public static final int HOURS= 3;	public String title() { return "Rate-Time-Distance"; }	public RTD_Nautical( Applet o ) {		super(o,4);		int[] d_RATE = { TIME, DISTANCE };		theFields[RATE]= new ModelField( this, "Rate (knots)", d_RATE );		int[] d_TIME = { RATE, DISTANCE };		theFields[TIME]= new ModelField( this, "Time (minutes)", d_TIME );		int[] d_DISTANCE = { RATE, TIME };		theFields[DISTANCE]= new ModelField( this, "Distance (nm)", d_DISTANCE );		int[] d_HOURS = { TIME };		theFields[HOURS]= new ModelField( this, "Time (hours)", d_HOURS );		theFields[HOURS].setEditable(false);	}	protected double model( int item ) {		if( item == RATE ) {			double time= theFields[TIME].get();			double dist= theFields[DISTANCE].get();			return 60 * dist / time;		}		if( item == TIME ) {			double rate= theFields[RATE].get();			double dist= theFields[DISTANCE].get();			return 60 * dist / rate;		}		if( item == DISTANCE ) {			double time= theFields[TIME].get();			double rate= theFields[RATE].get();			return rate * time / 60;		}		if( item == HOURS ) {			double time= theFields[TIME].get();			return time / 60;		}		return 0.0;	}}class FC_Temp extends Model {	public static final int F= 0;	public static final int C= 1;	public String title() { return "Temperature F-C"; }	public FC_Temp( Applet o ) {		super(o,2);		int[] d_F = { C };		theFields[F]= new ModelField( this, "Temp (¡F)", d_F );		int[] d_C = { F };		theFields[C]= new ModelField( this, "Temp (¡C)", d_C );	}	protected double model( int item ) {		if( item == F ) {			double c= theFields[C].get();			return c*(212.-32.)/100.+32.;		}		if( item == C ) {			double f= theFields[F].get();			return (f-32.)*100./(212.-32.);		}		return 0.0;	}}class FreqWaveL extends Model {	public static final int F= 0;	public static final int W= 1;	public String title() { return "Frequency-Wavelength"; }	public FreqWaveL( Applet o ) {		super(o,2);		int[] d_F = { W };		theFields[F]= new ModelField( this, "Frequency (MHz)", d_F );		int[] d_W = { F };		theFields[W]= new ModelField( this, "Wavelength (m)", d_W );	}	protected double model( int item ) {		if( item == F ) {			double w= theFields[W].get();			return 300/w;		}		if( item == W ) {			double f= theFields[F].get();			return 300/f;		}		return 0.0;	}}class DiamAWG extends Model {	public static final int AWG= 0;	public static final int DIAM= 1;	private static final double k=Math.pow(0.46/0.005,1.0/39.0);	public String title() { return "AWG#-Diameter"; }	public DiamAWG( Applet o, int nv ) { super(o,nv); }	public DiamAWG( Applet o ) {		super(o,2);		int[] d_AWG = { DIAM };		theFields[AWG]= new ModelField( this, "AWG#", d_AWG );		int[] d_DIAM= { AWG };		theFields[DIAM]= new ModelField( this, "Wire Diameter (in)", d_DIAM );	}	protected double awg( double d ) {			return 39*(Math.log(0.46/d)/Math.log(0.46/0.005))-3;			// -6*Math.log(d/0.3238)/Math.log(2)	}	protected double diam( double g ) {			return 0.46/Math.pow(k,g+3);			// 0.3238*Math.pow(2,g/-6)	}	protected double model( int item ) {		if( item == AWG ) {			double d= theFields[DIAM].get();			return awg(d);		}		if( item == DIAM ) {			double g= theFields[AWG].get();			return diam(g);		}		return 0.0;	}}class DiamAWGTPI extends DiamAWG {	public static final int AWG= 0;	public static final int DIAM= 1;	public static final int TPI= 2;	public String title() { return "AWG#-Diameter-Turns per Inch"; }	public DiamAWGTPI( Applet o, int nv ) { super(o,nv); }	public DiamAWGTPI( Applet o ) {		super(o,3);		int[] d_AWG = { DIAM };		theFields[AWG]= new ModelField( this, "AWG#", d_AWG );		int[] d_DIAM= { AWG };		theFields[DIAM]= new ModelField( this, "Wire Diameter (in)", d_DIAM );		int[] d_TPI= { DIAM };		theFields[TPI]= new ModelField( this, "Turns per Inch", d_TPI );		theFields[TPI].setEditable(false);	}	protected double model( int item ) {		if( item == AWG ) {			double d= theFields[DIAM].get();			return awg(d);		}		if( item == DIAM ) {			double g= theFields[AWG].get();			return diam(g);		}		if( item == TPI ) {			double d= theFields[DIAM].get();			return 1./d;		}		return 0.0;	}}class DiamAWGOHM extends DiamAWGTPI {	public static final int AWG= 0;	public static final int DIAM= 1;	public static final int TPI= 2;	public static final int OHM= 3;	public String title() { return "AWG#-Diameter-turns and Ohms per Inch"; }	public DiamAWGOHM( Applet o ) {		super(o,4);		int[] d_AWG = { DIAM };		theFields[AWG]= new ModelField( this, "AWG#", d_AWG );		int[] d_DIAM= { AWG };		theFields[DIAM]= new ModelField( this, "Wire Diameter (in)", d_DIAM );		int[] d_TPI= { DIAM };		theFields[TPI]= new ModelField( this, "Turns per Inch", d_TPI );		theFields[TPI].setEditable(false);		int[] d_OHM= { AWG };		theFields[OHM]= new ModelField( this, "Ohms per Inch", d_OHM );		theFields[OHM].setEditable(false);	}	protected double model( int item ) {		if( item == AWG ) {			double d= theFields[DIAM].get();			return awg(d);		}		if( item == DIAM ) {			double g= theFields[AWG].get();			return diam(g);		}		if( item == TPI ) {			double d= theFields[DIAM].get();			return 1./d;		}		if( item == OHM ) {			double g= theFields[AWG].get();			double d= diam(g);			double c= (d*1000.0)*(d*1000.0);			return 10574.0/c;		}		return 0.0;	}}class U555Multi extends Model {	public static final int F= 0;	public static final int R1= 1;	public static final int R2= 2;	public static final int C1= 3;	public static final int HT= 4;	public static final int LT= 5;	public static final int DC= 6;	public String title() { return "555 Timer: Astable Multivibrator"; }	public U555Multi( Applet o ) {		super(o,7);		int[] d_F = { R1, R2, C1 };		theFields[F]= new ModelField( this, "Frequency (Hz)", d_F );		int[] d_R1= { C1, F, R2 };		theFields[R1]= new ModelField( this, "R1 (Ohms)", d_R1 );		int[] d_R2= { C1, F, R1 };		theFields[R2]= new ModelField( this, "R2 (Ohms)", d_R2 );		int[] d_C1= { R1, R2, F };		theFields[C1]= new ModelField( this, "C1 (µF)", d_C1 );		int[] d_HT = { R1, R2, C1 };		theFields[HT]= new ModelField( this, "High Time (ms)", d_HT );		int[] d_LT = { R2, C1 };		theFields[LT]= new ModelField( this, "Low Time (ms)", d_LT );		int[] d_DC = { R1, R2, C1 };		theFields[DC]= new ModelField( this, "Duty Cycle (%)", d_DC );	}	protected double model( int item ) {		if( item == F ) {			double r1= theFields[R1].get();			double r2= theFields[R2].get();			double c1= theFields[C1].get()/1.0e6;			return 1./.693/((r1+2.*r2)*c1);		}		if( item == R1 ) {			double f= theFields[F].get();			double r2= theFields[R2].get();			double c1= theFields[C1].get()/1.0e6;			return 1./.693/(c1*f)-2.*r2;		}		if( item == R2 ) {			double f= theFields[F].get();			double r1= theFields[R1].get();			double c1= theFields[C1].get()/1.0e6;			return 1./(.693/(2./(c1*f)))-r1/2.;		}		if( item == C1 ) {			double f= theFields[F].get();			double r1= theFields[R1].get();			double r2= theFields[R2].get();			return 1.0e6/.693/((r1+2.*r2)*f);		}		if( item == HT ) {			double r1= theFields[R1].get();			double r2= theFields[R2].get();			double c1= theFields[C1].get()/1.0e6;			return .693*(r1+r2)*c1*1000.;		}		if( item == LT ) {			double r2= theFields[R2].get();			double c1= theFields[C1].get()/1.0e6;			return .693*r2*c1*1000;		}		if( item == DC ) {			double ht= theFields[HT].get();			double lt= theFields[LT].get();			return 100*ht/(ht+lt);		}		return 0.0;	}}class U555Single extends Model {	public static final int D= 0;	public static final int R1= 1;	public static final int C1= 2;	public String title() { return "555 Timer: Monostable One-shot"; }	public U555Single( Applet o ) {		super(o,3);		int[] d_D = { R1, C1 };		theFields[D]= new ModelField( this, "Pulse (seconds)", d_D );		int[] d_R1= { C1, D };		theFields[R1]= new ModelField( this, "R1 (Ohms)", d_R1 );		int[] d_C1= { R1, D };		theFields[C1]= new ModelField( this, "C1 (µF)", d_C1 );	}	protected double model( int item ) {		if( item == D ) {			double r1= theFields[R1].get();			double c1= theFields[C1].get()/1.0e6;			return (1./.693)*r1*c1;		}		if( item == R1 ) {			double d= theFields[D].get();			double c1= theFields[C1].get()/1.0e6;			return d/((1./.693)*c1);		}		if( item == C1 ) {			double d= theFields[D].get();			double r1= theFields[R1].get();			return 1.0e6*d/((1./.693)*r1);		}		return 0.0;	}}class PiAtten extends Model {	public static final int Z= 0;	public static final int D= 1;	public static final int R1= 2;	public static final int R2= 3;	public String title() { return "Pi-network Attenuator"; }	public PiAtten( Applet o ) {		super(o,4);		int[] d_Z = {};		theFields[Z]= new ModelField( this, "Impedance (Ohms)", d_Z );		int[] d_D = {};		theFields[D]= new ModelField( this, "Attenuation (dB)", d_D );		int[] d_R1= { Z, D };		theFields[R1]= new ModelField( this, "R1 (Ohms)", d_R1 );		int[] d_R2= { R1, Z, D };		theFields[R2]= new ModelField( this, "R2 (Ohms)", d_R2 );	}	protected double model( int item ) {		if( item == R1 ) {			double p= theFields[D].get()*0.05;	//power			double z= theFields[Z].get();			double r1= z*(Math.pow(10.,p)+1.)/(Math.pow(10.,p)-1.);			theFields[R1].set( r1 );			return r1;		}		if( item == R2 ) {			double p= theFields[D].get()*0.05;	//power			double z= theFields[Z].get();			double r1= theFields[R1].get();			return z*r1*(Math.pow(10.,p)-1.)/(z+r1);		}		return 0.0;	}}class TAtten extends Model {	public static final int Z= 0;	public static final int D= 1;	public static final int R1= 2;	public static final int R2= 3;	public String title() { return "T-Section Attenuator"; }	public TAtten( Applet o ) {		super(o,4);		int[] d_Z = {};		theFields[Z]= new ModelField( this, "Impedance (Ohms)", d_Z );		int[] d_D = {};		theFields[D]= new ModelField( this, "Attenuation (dB)", d_D );		int[] d_R1= { Z, D };		theFields[R1]= new ModelField( this, "R1 (Ohms)", d_R1 );		int[] d_R2= { R1, Z, D };		theFields[R2]= new ModelField( this, "R2 (Ohms)", d_R2 );	}	protected double model( int item ) {		if( item == R1 ) {			double p= theFields[D].get()*0.05;	//power			double z= theFields[Z].get();			double r1= z*(Math.pow(10,p)-1.)/(Math.pow(10,p)+1.);			theFields[R1].set( r1 );			return r1;		}		if( item == R2 ) {			double p= theFields[D].get()*0.05;	//power			double z= theFields[Z].get();			double r1= theFields[R1].get();			return (r1+z)/(Math.pow(10.,p)-1.);		}		return 0.0;	}}class ShortAntenna extends Model {	public static final int F= 0;	public static final int DIAM= 1;	public static final int SP= 2;	public static final int LG= 3;	public static final int B= 4;	public static final int C= 5;	public static final int L= 6;	public String title() { return "Short Antenna"; }	public ShortAntenna( Applet o ) {		super(o,7);		int[] d_F = { };		theFields[F]= new ModelField( this, "Frequency (MHz)", d_F );		int[] d_DIAM = { };		theFields[DIAM]= new ModelField( this, "Wire Diameter (in)", d_DIAM );		int[] d_SP = { F };		theFields[SP]= new ModelField( this, "Best Size (ft)", d_SP );		theFields[SP].setEditable(false);		int[] d_LG = { };		theFields[LG]= new ModelField( this, "Available Space (ft)", d_LG );		int[] d_B = { };		theFields[B]= new ModelField( this, "Center to Coil (ft)", d_B );		int[] d_C = { LG, B };		theFields[C]= new ModelField( this, "Coil to End (ft)", d_C );		theFields[C].setEditable(false);		int[] d_L = { LG, B, DIAM, F };		theFields[L]= new ModelField( this, "Inductance (µH)", d_L );	}	protected double model( int item ) {		if( item == SP ) {			double f= theFields[F].get();			double dia= theFields[DIAM].get();			return 300./f*.656;		}		if( item == C ) {			double lg= theFields[LG].get();			double b= theFields[B].get();			return lg/2.-b;		}		if( item == L ) {			double f= theFields[F].get();			double dia= theFields[DIAM].get();			double lg= theFields[LG].get();			double b= theFields[B].get();			double f1= 1.0e6/(68.*Math.PI*Math.PI*f*f);			double f2= Math.log((24.*(234./f)-b)/dia-1.);			double f3= Math.pow(1.-f*b/234.,2)-1.;			double f4= 234./f-b;			double f5= Math.log((24.*lg/2.-b)/dia-1.);			double f6= Math.pow((f*lg/2-f*b)/234.,2)-1.;			double f7= lg/2.-b;			return f1*(f2*f3/f4-f5*f6/f7);		}		return 0.0;	}}class Antenna extends Model {	public static final int F= 0;	public static final int DIAM= 1;	public static final int LEN2F= 2;	public static final int LEN2D= 3;	public static final int LEN1= 4;	public String title() { return "Antenna"; }	public Antenna( Applet o ) {		super(o,5);		int[] d_F = { };		theFields[F]= new ModelField( this, "Frequency (MHz)", d_F );		int[] d_DIAM = { };		theFields[DIAM]= new ModelField( this, "Wire Diameter (in)", d_DIAM );		int[] d_LEN2F = { F };		theFields[LEN2F]= new ModelField( this, "1/2W Flat Top(ft)", d_LEN2F );		theFields[LEN2F].setEditable(false);		int[] d_LEN2D = { F };		theFields[LEN2D]= new ModelField( this, "1/2W Dipole Leg (ft)", d_LEN2D );		theFields[LEN2D].setEditable(false);		int[] d_LEN1 = { F };		theFields[LEN1]= new ModelField( this, "1W Vertical (ft)", d_LEN1 );		theFields[LEN1].setEditable(false);	}	private double k( double f, double dia ) {		double r= (12*492/f)/dia;		if( r > 2000 ) return .98;		if( r > 200 ) return .97;		if( r > 50 ) return .96;		if( r > 22 ) return .95;		if( r > 15 ) return .94;		if( r > 12 ) return .93;		if( r > 10 ) return .92;		return .91;	}	protected double model( int item ) {		if( item == LEN1 ) {			double f= theFields[F].get();			double dia= theFields[DIAM].get();			return 492.*(2.-.05)/f;		}		if( item == LEN2F ) {			double f= theFields[F].get();			double dia= theFields[DIAM].get();			return 492.*k(f,dia)/f;		}		if( item == LEN2D ) {			double f= theFields[F].get();			double dia= theFields[DIAM].get();			//factor in wire end-effects under 3 Mhz			return (492.*k(f,dia)/f)/2.;		}		return 0.0;	}}class AudioFilt extends Model {	public static final int C1= 0;	public static final int C2= 1;	public String title() { return "Audio Filter"; }	private ModelNumChoice cap1List;	private ModelNumChoice cap2List;	public AudioFilt( Applet o ) { super(o,2);		cap1List= new ModelNumChoice();		cap1List.addItem( "470" );		cap1List.addItem( "560" );		cap1List.addItem( "680" );		cap1List.addItem( "820" );		cap1List.addItem( "1000" );		cap1List.addItem( "1200" );		cap1List.addItem( "1500" );		cap1List.addItem( "1800" );		cap1List.addItem( "2200" );		cap2List= new ModelNumChoice();		cap2List.addItem( "470" );		cap2List.addItem( "560" );		cap2List.addItem( "680" );		cap2List.addItem( "820" );		cap2List.addItem( "1000" );		cap2List.addItem( "1200" );		cap2List.addItem( "1500" );		cap2List.addItem( "1800" );		cap2List.addItem( "2200" );		int[] d_C1 = { };		theFields[C1]= new ModelField( this, "C1 (pF)", d_C1, cap1List );		int[] d_C2 = { };		theFields[C2]= new ModelField( this, "C2 (pF)", d_C2, cap2List );	}	protected double model( int item ) {		if( item == C1 ) {			double c2= theFields[C1].get();			return c2;		}		if( item == C2 ) {			double c1= theFields[C1].get();			return c1;		}		return 0.0;	}}class LC_Resonant extends Model {	public static final int F= 0;	public static final int C= 1;	public static final int Z= 2;	public static final int L= 3;	public String title() { return "LC Resonant Circuit"; }	public LC_Resonant( Applet o ) {		super(o,4);		theFields[F]= new ModelField( this, "Frequency (MHz)" );		theFields[C]= new ModelField( this, "Capacitance (pF)" );		theFields[Z]= new ModelField( this, "Reactance (½)" );		theFields[L]= new ModelField( this, "Inductance (µH)" );	}	public boolean computable( int item ) { // dependency rules		if( item == F		&& theFields[L].setAfter( theFields[F] )		&& theFields[C].setAfter( theFields[F] ) ) return true;		if( item == L ) {			if( theFields[F].setAfter( theFields[L] )			&& theFields[C].setAfter( theFields[L] ) ) return true;			if( theFields[F].setAfter( theFields[L] )			&& theFields[Z].setAfter( theFields[L] ) ) return true;			return false;		}		if( item == C ) {			if( theFields[F].setAfter( theFields[C] )			&& theFields[L].setAfter( theFields[C] ) ) return true;			if( theFields[F].setAfter( theFields[C] )			&& theFields[Z].setAfter( theFields[C] ) ) return true;			return false;		}		if( item == Z		&& theFields[F].setAfter( theFields[Z] )		&& theFields[C].setAfter( theFields[Z] ) ) return true;		return false;	}	protected double model( int item ) {		if( item == F ) {			double l= theFields[L].get();			double c= theFields[C].get();			return Math.sqrt( 25330./c/l );		}		if( item == L ) {			double f= theFields[F].get();			double c= theFields[C].get();			double z= theFields[Z].get();			if( f > 0.0 && c > 0.0 )				return 25330./(f*f)/c;			if( f > 0.0 && z > 0.0 )				return z/(2.*Math.PI*f);			return 0.0;		}		if( item == C ) {			double f= theFields[F].get();			double l= theFields[L].get();			double z= theFields[Z].get();			if( f > 0.0 && l > 0.0 )				return 25330./(f*f)/l;			if( f > 0.0 && z > 0.0 )				return 1./(2.*Math.PI*f*z);			return 0.0;		}		if( item == Z ) {			double f= theFields[F].get();			double c= theFields[C].get();			return 1.0e6/(2.*Math.PI*f*c);		}		return 0.0;	}}class AirCore extends Model {	public static final int LDR= 0;	public static final int TPI= 1;	public static final int L= 2;	public static final int CD= 3;	public static final int N= 4;	public static final int LW= 5;	public String title() { return "Air Core Coil"; }	public AirCore( Applet o ) {		super(o,6);		int[] d_LDR = { CD, N, TPI };		theFields[LDR]= new ModelField( this, "Length/Diam. Ratio", d_LDR );		int[] d_TPI = { };		theFields[TPI]= new ModelField( this, "Turns per Inch", d_TPI );		int[] d_L = { CD, N, TPI };		theFields[L]= new ModelField( this, "Inductance (µH)", d_L );		int[] d_CD = { LDR, TPI, L };		theFields[CD]= new ModelField( this, "Coil Diameter (in)", d_CD );		int[] d_N = { CD, L, TPI, LDR };		theFields[N]= new ModelField( this, "Coil Turns", d_N );		int[] d_LW= { CD, N };		theFields[LW]= new ModelField( this, "Wire Length (in)", d_LW );		theFields[LW].setEditable(false);		theFields[LDR].set( 1.5 );	}	private double turns( double cd, double ld, double l ) {		return Math.sqrt( l*(18*cd+40*ld*cd) )/cd;	}	private double coil( double cd, double ld, double l, double tpi ) {		return turns(cd,ld,l)/tpi-ld*cd;	}	private double uh( double cd, double n, double tpi ) {		return ((cd/2)*(cd/2)*n*n)/(9.0*cd/2+10.0*n/tpi);	}	private double plan_diam( double tpi, double l, double ld ) {			// phase 1, bracket a zero -- move cd1 and cd2 until			// coil(cd1...) and coil(cd2...) have different signs			double cd1= 1.0;			double cd2= 2.0;			double f1= coil( cd1, ld, l, tpi );			double f2= coil( cd2, ld, l, tpi );			int t= 50;			while( t > 0 && f1*f2 >= 0.0 ) {				--t;				//System.err.println("f("+cd1+")="+f1+", f("+cd2+")="+f2);				if( Math.abs(f1) < Math.abs(f2) ) {					cd1+= 1.6*(cd1-cd2);					f1= coil(cd1,ld,l,tpi);				}				else {					cd2+= 1.6*(cd2-cd1);					f2= coil(cd2,ld,l,tpi);				}			}			//System.err.println("f("+cd1+")="+f1+", f("+cd2+")="+f2);			// phase 2, bisect to find the zero between cd1 and cd2 (rtb=root by bisection)			double rtb, dx, cdMid;			// estimate root (rtb) and slope (dx)			if( f1 < 0.0 ) { dx=cd2-cd1; rtb=cd1; }			else { dx= cd1-cd2; rtb= cd2; }			t= 50;			while( t > 0 && ( Math.abs(dx) > 0.001 || f2 == 0.0 ) ) {				--t;				//System.err.println("f("+rtb+"+"+dx+")="+f2);				dx *= 0.5;  cdMid= rtb+dx;				f2= coil(cdMid,ld,l,tpi);				if( f2 <= 0.0 ) rtb= cdMid;			}			return rtb;	}	protected double model( int item ) {		if( item == LDR ) {			double cd= theFields[CD].get();			double n= theFields[N].get();			double tpi= theFields[TPI].get();			return (n/tpi)/cd;		}		if( item == L ) {			double cd= theFields[CD].get();			double n= theFields[N].get();			double tpi= theFields[TPI].get();			return uh(cd,n,tpi);		}		if( item == CD ) {			double tpi= theFields[TPI].get();			double l= theFields[L].get();			double ld= theFields[LDR].get();			double cd= plan_diam(tpi,l,ld);			double n= turns(cd,ld,l);			theFields[N].compute( n );			theFields[LW].compute( cd*n*Math.PI );			return cd;		}		if( item == N ) {			double cd= theFields[CD].get();			double ld= theFields[LDR].get();			double l= theFields[L].get();			double tpi= theFields[TPI].get();			double n= turns(cd,ld,l);			theFields[LDR].compute( n/tpi/cd );			theFields[LW].compute( cd*n*Math.PI );			return turns(cd,ld,l);		}		if( item == LW ) {			double cd= theFields[CD].get();			double n= theFields[N].get();			return cd*n*Math.PI;		}		return 0.0;	}}// This class simply instantiates a specific model given the name// of the model.  It is a separate class to simplify (slightly) the main// appletclass ModelFactory {	Model makeModel( Applet client, String modelName ) {		if( modelName.toLowerCase().equals("aircore") )			return new AirCore(client);		if( modelName.toLowerCase().equals("antenna") )			return new Antenna(client);		if( modelName.toLowerCase().equals("audiofilt") )		return new AudioFilt(client);		if( modelName.toLowerCase().equals("diamawg") )			return new DiamAWG(client);		if( modelName.toLowerCase().equals("diamawgtpi") )		return new DiamAWGTPI(client);		if( modelName.toLowerCase().equals("diamawgohm") )		return new DiamAWGOHM(client);		if( modelName.toLowerCase().equals("fc_temp") )			return new FC_Temp(client);		if( modelName.toLowerCase().equals("freqwavel") )		return new FreqWaveL(client);		if( modelName.toLowerCase().equals("lc_resonant") )		return new LC_Resonant(client);		if( modelName.toLowerCase().equals("piatten") )			return new PiAtten(client);		if( modelName.toLowerCase().equals("rtd_nautical") )	return new RTD_Nautical(client);		if( modelName.toLowerCase().equals("rtd_statute") )		return new RTD_Statute(client);		if( modelName.toLowerCase().equals("shortantenna") )	return new ShortAntenna(client);		if( modelName.toLowerCase().equals("tatten") )			return new TAtten(client);		if( modelName.toLowerCase().equals("u555multi") )		return new U555Multi(client);		if( modelName.toLowerCase().equals("u555single") )		return new U555Single(client);		return null;	}}// The applet is an observer of the various models it instantiates, it can then// pass data from model to model.// The applet parses paramters and creates an array of models.// It then interrogates each models and fills up a panel with model title and fields.// A grid of all model panels fills the applet's frame.public class RadioCalc extends java.applet.Applet implements java.util.Observer {	int models= 0;	ModelFactory theFactory= new ModelFactory();	Model theModel[];	// browsers use this to display information about this applet	public String[][] getParameterInfo() {		String pinfo[][] = {			{"numModels", "int", "Number of models (default 1)"},			{"model0", "String", "Model name (RTD_Nautical, RTD_Statute,"},			{"model1", "String", "FC_Temp, FreqWaveL, LC_Resonant,...)"},			{"modeln", "String", "..."}		};		return pinfo;	}	// stand-alone applications use this	public void main() {		// need to create a frame		init();		start();	}	// parse the HTML parameters to the applet	void parseParam() {		// how many models?		String numModels= getParameter( "numModels" );		if( ! numModels.equals("") ) {			models= Integer.parseInt(numModels);		}		else {			models= 1;		}		theModel= new Model[models];		// instantiate the models		for( int m= 0; m != models; ++m ) {			String modelName= getParameter( "model" + m);			//System.err.println("Model " + m + ": " + modelName );			theModel[m]= theFactory.makeModel( this, modelName );			if( theModel[m] == null ) {				System.err.println( "Model"+m+" " + modelName + " unknown" );				showStatus("HTML Error:  Model " + modelName + " unknown");			}		}	}	// create the form:  it uses grid-bag layout to have variable-sized	// sections for each model.	// for each model,	// put in a label for the model's title, then a panel for the model	void createForm() {		Dimension separator= new Dimension( size().width, 2 );		GridBagLayout appletLayout= new GridBagLayout();		GridBagConstraints gbc= new GridBagConstraints();		gbc.weightx= 100; gbc.weighty= 50;		setLayout( appletLayout );		int yTop= 0;		for( int m= 0; m != models; ++m ) {			// set constraints and slap a separator into the applet's GBLayout			gbc.gridx= 0; gbc.gridy= yTop;			gbc.gridwidth= 1; gbc.gridheight= 1;			Label border= new Label( theModel[m].title() );			appletLayout.setConstraints( border, gbc );			this.add( border );			yTop+= gbc.gridheight;			// create a panel full of fields for the model			Panel p= new Panel();			createModelPanel( p, m );			theModel[m].thePanel= p;			// set constraints and slap this panel into the applet's GridBagLayout			gbc.gridx= 0; gbc.gridy= yTop;			gbc.gridwidth= 1; gbc.gridheight= theModel[m].numVariables();			appletLayout.setConstraints( p, gbc );			this.add( p );			yTop+= gbc.gridheight;		}	}	// for a specific model, create the label and AWT component for each field	Panel createModelPanel( Panel fieldsPanel, int m ) {			// fields form a regular grid, indefinite rows, 2 columns			fieldsPanel.setLayout( new GridLayout(0,2) );			// for each field, drop in the label and the component			for( int i= 0; i != theModel[m].numVariables(); ++i ) {				Label l= new Label( theModel[m].getLabel(i), Label.RIGHT );				fieldsPanel.add( l );				ModelField f= theModel[m].getField(i);				fieldsPanel.add( (Component)f.theComponent );			}			return fieldsPanel;	}	// applet initialization:  get parameters, build form, set up observer	// chain among models	public void init() {		// parse the parameters and set up the array of models.		parseParam();		// create the form and set up a grid of labels and fields		createForm();		// add the applet as an observer of the model		// make this model observe all prior models		for( int m= 0; m != models; ++m ) {			theModel[m].addObserver( this );			for( int p= 0; p != m; ++p ) {				theModel[p].addObserver( theModel[m] );			}		}	}	// observables will notify us via this update method	public void update( Observable obj, Object what ) {		for( int m= 0; m != models; ++m ) {			if( theModel[m].hasChanged() ) {				for( int i= 0; i != theModel[m].numVariables(); ++i ) {					//System.err.println( "Item["+i+"]="+theModel[m].get(i) );					theModel[m].getField(i).setValue( theModel[m].get(i) );				}			}		}	}}